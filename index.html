<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Boxicons -->
    <link
      href="https://unpkg.com/boxicons@2.0.9/css/boxicons.min.css"
      rel="stylesheet"
    />
    <!-- My CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="style.css" />
    <link rel="icon" href="./img/logoTelkom.png" type="image/x-icon" />
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
    <title>DDoS Threat Map</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"
      integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <style>
      #map-container {
        width: 75vw;
        height: 75vh;
        padding: 10px;
        background-color: #060714;
        border-radius: 15px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        border: 1px solid #ddd;
        margin-left: 12.25vw;
        margin-top: 10vh;
      }

      svg {
        width: 100%;
        height: 100%;
        border-radius: 10px;
      }

      .land {
        fill: grey;
        stroke: #333;
        stroke-width: 0.5px;
      }

      .land:hover {
        fill: blue;
      }

      .markerRed {
        fill: red;
        stroke: black;
        stroke-width: 1px;
      }
      .markerYellow {
        fill: yellow;
        stroke: black;
        stroke-width: 1px;
      }

      .pulseRed {
        fill: none;
        stroke: red;
        stroke-width: 2px;
        opacity: 0.7;
      }
      .pulseYellow {
        fill: none;
        stroke: yellow;
        stroke-width: 2px;
        opacity: 0.7;
      }
      .modal-content {
        background-color: #1e1e1e;
        color: white;
      }

      .modal-header {
        border-bottom: 1px solid #444;
      }

      .modal-footer {
        border-top: 1px solid #444;
      }

      .lineRed {
        fill: none;
        stroke: red;
        stroke-width: 2px;
        opacity: 0.7;
      }
      .lineYellow {
        fill: none;
        stroke: yellow;
        stroke-width: 2px;
        opacity: 0.7;
      }
    </style>
  </head>
  <body class="dark">
    <!-- NAVBAR -->
    <nav>
      <img src="./img/logoTelkom.png" id="logo" />
    </nav>
    <!-- NAVBAR -->

    <!-- MAIN -->
    <main>
      <ul class="box-info">
        <li>
          <i class="fa-solid fa-land-mine-on fa-2xl" style="color: #74c0fc"></i>
          <span class="text">
            <h3 id="ongoing-attack-count">0</h3>
            <p>On-going Attack</p>
          </span>
        </li>
        <li>
          <i
            class="fa-solid fa-triangle-exclamation fa-2xl"
            style="color: #ff0000"
          ></i>
          <span class="text">
            <h3 id="ongoing-attack-count-red">0</h3>
            <p>Red Severity On-going Attack</p>
          </span>
        </li>
        <li>
          <i
            class="fa-solid fa-triangle-exclamation fa-2xl"
            style="color: #ffd43b"
          ></i>
          <span class="text">
            <h3 id="ongoing-attack-count-yellow">0</h3>
            <p>Yellow Severity On-going Attack</p>
          </span>
        </li>
      </ul>
      <div id="map-container">
        <svg></svg>
      </div>

      <div class="table-data">
        <div class="todo">
          <div class="head">
            <h3>Top Targeted IP</h3>
          </div>
          <ul class="todo-list"></ul>
        </div>
      </div>
    </main>
    <!-- MAIN -->

    <!-- Modal HTML -->
    <div
      class="modal fade"
      id="recordModal"
      tabindex="-1"
      aria-labelledby="recordModalLabel"
      aria-hidden="true"
    >
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="recordModalLabel">Attack Details</h5>
            <button
              type="button"
              class="btn-close"
              data-bs-dismiss="modal"
              aria-label="Close"
            ></button>
          </div>
          <div class="modal-body">
            <p><strong>ID:</strong> <span id="modal-id"></span></p>
            <p><strong>CHK:</strong> <span id="modal-chk"></span></p>
            <p>
              <strong>Direction:</strong> <span id="modal-direction"></span>
            </p>
            <p><strong>Resource:</strong> <span id="modal-resource"></span></p>
            <p><strong>Severity:</strong> <span id="modal-severity"></span></p>
            <p>
              <strong>StartTime:</strong> <span id="modal-starttime"></span>
            </p>
            <p><strong>Type:</strong> <span id="modal-type"></span></p>
            <p><strong>Victim Ip:</strong> <span id="modal-victimip"></span></p>
            <p><strong>Source IP:</strong> <span id="modal-sourceip"></span></p>
          </div>
          <div class="modal-footer">
            <button
              type="button"
              class="btn btn-secondary"
              data-bs-dismiss="modal"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- TOOLTIP -->
    <div
      id="tooltip"
      style="
        position: absolute;
        background: #fff;
        border: 1px solid #ddd;
        padding: 5px;
        border-radius: 3px;
        pointer-events: none;
        display: none;
      "
    ></div>
    <!-- JavaScript SDK -->
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"
      integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
      integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
      crossorigin="anonymous"
    ></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <script type="module">
      import {
        select,
        json,
        geoPath,
        geoNaturalEarth1,
        zoom,
        easeCubicInOut,
      } from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
      import { feature } from "https://cdn.jsdelivr.net/npm/topojson@3/+esm";
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.0.0/firebase-app.js";
      import {
        getFirestore,
        collection,
        onSnapshot,
        Timestamp,
        doc,
        updateDoc,
        getDocs,
      } from "https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore.js";
      import dayjs from "https://cdn.jsdelivr.net/npm/dayjs@1.10.4/+esm";
      import utc from "https://cdn.jsdelivr.net/npm/dayjs@1.10.4/plugin/utc/+esm";
      import anime from "https://cdn.jsdelivr.net/npm/animejs@3.2.1/+esm";

      dayjs.extend(utc);

      const firebaseConfig = {
        apiKey: "AIzaSyDzNSCSlTiMSBxf7zQxhu3dndEvuD2dDvU",
        authDomain: "attack-project-e76d9.firebaseapp.com",
        projectId: "attack-project-e76d9",
        storageBucket: "attack-project-e76d9.appspot.com",
        messagingSenderId: "695858311909",
        appId: "1:695858311909:web:e782027cd98f883c991a0c",
        measurementId: "G-83WY3CG3VN",
      };
      const ipInfoToken = "3949280a8aa576";

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);

      let onGoingYellowAttack = [];
      let onGoingRedAttack = [];

      function addOnGoingAttack(data) {
        const currentTime = dayjs().utcOffset(7).toDate();
        // cek apakah dia memenuhi syarat on-gooing
        if (
          data.Status === "On-going" ||
          (data.EndTime && timestampToDate(data.EndTime) > currentTime)
        ) {
          // jika memenuhi, cek apakah dia merupakan red severity
          if (data.Severity.includes("red /")) {
            // jika iya, cek apakah id nya ada di onGoingRedAttack
            if (!onGoingRedAttack.includes(data.id)) {
              // jika tidak ada, push ke array onGoingRedAttack
              onGoingRedAttack.push(data.id);
            }
          } else {
            //  lakukan hal yang sama pada yellow attack
            if (!onGoingYellowAttack.includes(data.id)) {
              onGoingYellowAttack.push(data.id);
            }
          }
        }
      }

      function removeOnGoingAttack(data) {
        const currentTime = dayjs().utcOffset(7).toDate();
        // cek apakah data memenuhi syarat on-going
        if (
          !(
            data.Status === "On-going" ||
            (data.EndTime && timestampToDate(data.EndTime) > currentTime)
          )
        ) {
          // jika tidak memenuhi, cek apakah dia merupakan red severity
          if (data.Severity.includes("red /")) {
            // jika merupakan red severity, cek apakah dia ada di dalam onGoingRedAttack
            if (onGoingRedAttack.includes(data.id)) {
              // jika ada, filter array sehingga tidak ada nilai tersebut (hapus id data tersebut dari onGoingRedAttack)
              onGoingRedAttack = onGoingRedAttack.filter(
                (item) => item !== data.id
              );
            }
          } else {
            // lakukan hal yang sama pada yellow severity attack
            if (onGoingYellowAttack.includes(data.id)) {
              onGoingYellowAttack = onGoingYellowAttack.filter(
                (item) => item !== data.id
              );
            }
          }
        }
      }

      // Fungsi untuk mengonversi Timestamp ke Date
      function timestampToDate(timestamp) {
        return timestamp.toDate();
      }

      // Fungsi untuk merender marker
      function renderMarkerByEndTime(el) {
        const currentTime = dayjs().utcOffset(7).toDate();
        const startTime = timestampToDate(el.StartTime);
        const endTime = timestampToDate(el.EndTime);
        const attackId = el.id; // ID serangan untuk mengidentifikasi elemen
        console.log({ currentTime: currentTime, startTime, endTime });
        var startPulseAnimation = false;

        let timeDifferenceInSeconds = 0;
        if (currentTime >= startTime && currentTime <= endTime) {
          timeDifferenceInSeconds = (endTime - currentTime) / 1000;
        }
        if (timeDifferenceInSeconds > 0) {
          const sourceIP = el.sourceIp;
          const destinationIP = el.VictimIp;
          let marker;

          const getGeoLocation = (ip) =>
            fetch(`https://ipinfo.io/${ip}/geo?token=3949280a8aa576`).then(
              (response) => response.json()
            );
          const getArrayGeolocation = (ips) => {
            const promises = ips.map((ip) =>
              fetch(`https://ipinfo.io/${ip}/geo?token=3949280a8aa576`).then(
                (response) => response.json()
              )
            );
            return Promise.all(promises);
          };

          Promise.all([
            getArrayGeolocation(sourceIP),
            getGeoLocation(destinationIP),
          ]).then((locations) => {
            const [sourceData, destinationData] = locations;

            let sourceCoords = [];
            sourceData.forEach((el) => {
              let [sourceLat, sourceLon] = el.loc.split(",");
              let sourceCoord = projection([sourceLon, sourceLat]);
              sourceCoords.push(sourceCoord);
            });

            const [destLat, destLon] = destinationData.loc.split(",");
            const destCoords = projection([destLon, destLat]);

            g.append("circle")
              .attr("cx", destCoords[0])
              .attr("cy", destCoords[1])
              .attr("r", 5)
              .attr("class", `marker marker-${attackId}`) // Kelas unik berdasarkan ID serangan
              .append("title")
              .text(`${destinationData.city}, ${destinationData.country}`);

            function createPulse(className) {
              const pulse = g
                .append("circle")
                .attr("class", `${className} pulse-${attackId}`) // Kelas unik berdasarkan ID serangan
                .attr("cx", destCoords[0])
                .attr("cy", destCoords[1])
                .attr("r", 5)
                .attr("opacity", 0.7);

              let radiusEnd = className === "pulseRed" ? 25 : 15;

              pulse
                .transition()
                .duration(1500)
                .ease(d3.easeCubicInOut)
                .attr("r", radiusEnd)
                .attr("opacity", 0)
                .on("end", () => {
                  pulse.remove();
                  if (startPulseAnimation && marker && !marker.empty()) {
                    createPulse(className);
                  }
                });
            }

            let idx = 0;

            function drawLine(className) {
              const lineGenerator = d3
                .line()
                .x((d) => d[0])
                .y((d) => d[1])
                .curve(d3.curveBasis);

              const points = [
                [sourceCoords[idx][0], sourceCoords[idx][1]],
                [
                  (sourceCoords[idx][0] + destCoords[0]) / 2,
                  sourceCoords[idx][1] - 100,
                ],
                [destCoords[0], destCoords[1]],
              ];

              const path = g
                .append("path")
                .attr("d", lineGenerator(points))
                .attr("class", `${className} line-${attackId}`); // Kelas unik berdasarkan ID serangan

              const totalLength = path.node().getTotalLength();

              path
                .attr("stroke-dasharray", totalLength + " " + totalLength)
                .attr("stroke-dashoffset", totalLength)
                .transition()
                .duration(2000)
                .ease(d3.easeCubicInOut)
                .attr("stroke-dashoffset", 0)
                .remove()
                .on("end", () => {
                  if (startPulseAnimation && marker && !marker.empty()) {
                    idx++;
                    if (idx >= sourceCoords.length) {
                      idx = 0;
                    }
                    drawLine(className);
                  }
                });
            }

            function createMarker(className) {
              marker = g
                .append("circle")
                .attr("class", `${className} marker-${attackId}`) // Kelas unik berdasarkan ID serangan
                .attr("cx", destCoords[0])
                .attr("cy", destCoords[1])
                .attr("r", 5)
                .on("mouseover", (event) => showTooltip(event, el))
                .on("mouseout", hideTooltip);

              startPulseAnimation = true;
              createPulse(
                className === "markerRed" ? "pulseRed" : "pulseYellow"
              );
              drawLine(className === "markerRed" ? "lineRed" : "lineYellow");
            }

            if (currentTime >= startTime && currentTime <= endTime) {
              console.log("mamang");
              createMarker(
                el.Severity.includes("red /") ? "markerRed" : "markerYellow"
              );

              // Hapus elemen berdasarkan ID serangan setelah timeout
              setTimeout(async () => {
                g.selectAll(
                  `.marker-${attackId}, .pulse-${attackId}, .line-${attackId}`
                ).remove();
                marker = null;
                startPulseAnimation = false;
                await resetAllAffterTimeout();

                // Hapus dari countOnGoing, CountRedSeverity, dan countYellowSeverity agar count-nya tetap benar
                if (countOnGoing.includes(el.id) && el.Status != "On-going") {
                  countOnGoing = countOnGoing.filter((item) => item !== el.id);
                }
                if (
                  countRedSeverity.includes(el.id) &&
                  el.Status != "On-going"
                ) {
                  countRedSeverity = countRedSeverity.filter(
                    (item) => item !== el.id
                  );
                }
                if (
                  countYellowSeverity.includes(el.id) &&
                  el.Status != "On-going"
                ) {
                  countYellowSeverity = countYellowSeverity.filter(
                    (item) => item !== el.id
                  );
                }
              }, timeDifferenceInSeconds * 1000); // Konversi ke milidetik
            }
          });
        }
      }

      async function getAllDDoSAttacks() {
        try {
          const ddosAttackCollection = collection(db, "DDoSAttack");
          const querySnapshot = await getDocs(ddosAttackCollection);
          const attackData = querySnapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));

          return attackData;
        } catch (error) {
          console.error("Error getting documents: ", error);
        }
      }

      async function resetAllAffterTimeout() {
        const currentTime = dayjs().utcOffset(7).toDate();
        const ddosAttack = await getAllDDoSAttacks();
        const onGoingCountBefore =
          onGoingRedAttack.length + onGoingYellowAttack.length;
        const onGoingRedCountBefore = onGoingRedAttack.length;
        const onGoingYellowCountBefore = onGoingYellowAttack.length;
        ddosAttack.forEach((el) => {
          // benerin lagi array onGoingAttack nya
          addOnGoingAttack(el);
          removeOnGoingAttack(el);
        });
        if (
          !(
            onGoingRedAttack.length + onGoingYellowAttack.length ==
            onGoingCountBefore
          )
        ) {
          animateCountUpdate(
            document.getElementById("ongoing-attack-count"),
            onGoingRedAttack.length + onGoingYellowAttack.length
          );
        }
        if (!(onGoingRedAttack.length == onGoingRedCountBefore)) {
          animateCountUpdate(
            document.getElementById("ongoing-attack-count-red"),
            onGoingRedAttack.length
          );
        }
        if (!(onGoingYellowAttack.length == onGoingYellowCountBefore)) {
          animateCountUpdate(
            document.getElementById("ongoing-attack-count-yellow"),
            onGoingYellowAttack.length
          );
        }
      }

      function renderMarkerByStatus(el) {
        const sourceIP = el.sourceIp;
        const destinationIP = el.VictimIp;
        const attackId = el.id; // Menggunakan ID serangan untuk ID elemen
        let startPulseAnimation, marker;

        const getGeoLocation = (ip) =>
          fetch(`https://ipinfo.io/${ip}/geo?token=3949280a8aa576`).then(
            (response) => response.json()
          );

        const getArrayGeolocation = (ips) => {
          const promises = ips.map((ip) =>
            fetch(`https://ipinfo.io/${ip}/geo?token=3949280a8aa576`).then(
              (response) => response.json()
            )
          );
          return Promise.all(promises);
        };

        Promise.all([
          getArrayGeolocation(sourceIP),
          getGeoLocation(destinationIP),
        ]).then((locations) => {
          const [sourceData, destinationData] = locations;

          let sourceCoords = [];
          sourceData.forEach((el) => {
            let [sourceLat, sourceLon] = el.loc.split(",");
            let sourceCoord = projection([sourceLon, sourceLat]);
            sourceCoords.push(sourceCoord);
          });

          const [destLat, destLon] = destinationData.loc.split(",");
          const destCoords = projection([destLon, destLat]);

          g.append("circle")
            .attr("cx", destCoords[0])
            .attr("cy", destCoords[1])
            .attr("r", 5)
            .attr("class", `marker marker-${attackId}`) // Menambahkan kelas khusus dengan ID
            .append("title")
            .text(`${destinationData.city}, ${destinationData.country}`);

          function createPulse(className) {
            const pulse = g
              .append("circle")
              .attr("class", `${className} pulse-${attackId}`) // Menambahkan kelas khusus dengan ID
              .attr("cx", destCoords[0])
              .attr("cy", destCoords[1])
              .attr("r", 5)
              .attr("opacity", 0.7);

            let radiusEnd = className === "pulseRed" ? 25 : 15;

            pulse
              .transition()
              .duration(1500)
              .ease(d3.easeCubicInOut)
              .attr("r", radiusEnd)
              .attr("opacity", 0)
              .on("end", () => {
                pulse.remove();
                if (startPulseAnimation && marker && !marker.empty()) {
                  createPulse(className);
                }
              });
          }

          let idx = 0;

          function drawLine(className) {
            const lineGenerator = d3
              .line()
              .x((d) => d[0])
              .y((d) => d[1])
              .curve(d3.curveBasis);

            const points = [
              [sourceCoords[idx][0], sourceCoords[idx][1]],
              [
                (sourceCoords[idx][0] + destCoords[0]) / 2,
                sourceCoords[idx][1] - 100,
              ],
              [destCoords[0], destCoords[1]],
            ];

            const path = g
              .append("path")
              .attr("d", lineGenerator(points))
              .attr("class", `${className} line-${attackId}`); // Menambahkan kelas khusus dengan ID

            const totalLength = path.node().getTotalLength();

            path
              .attr("stroke-dasharray", totalLength + " " + totalLength)
              .attr("stroke-dashoffset", totalLength)
              .transition()
              .duration(2000)
              .ease(d3.easeCubicInOut)
              .attr("stroke-dashoffset", 0)
              .remove()
              .on("end", () => {
                if (startPulseAnimation && marker && !marker.empty()) {
                  idx++;
                  if (idx >= sourceCoords.length) {
                    idx = 0;
                  }
                  drawLine(className);
                }
              });
          }

          function createMarker(className) {
            marker = g
              .append("circle")
              .attr("class", `${className} marker-${attackId}`) // Menambahkan kelas khusus dengan ID
              .attr("cx", destCoords[0])
              .attr("cy", destCoords[1])
              .attr("r", 5)
              .on("mouseover", (event) => showTooltip(event, el))
              .on("mouseout", hideTooltip);

            startPulseAnimation = true;
            createPulse(className === "markerRed" ? "pulseRed" : "pulseYellow");
            drawLine(className === "markerRed" ? "lineRed" : "lineYellow");
          }

          if (el.Status === "On-going") {
            createMarker(
              el.Severity.includes("red /") ? "markerRed" : "markerYellow"
            );
          }

          // Listener untuk memantau perubahan status
          onSnapshot(doc(db, "DDoSAttack", attackId), (docSnapshot) => {
            const updatedData = docSnapshot.data();
            if (updatedData.Status !== "On-going") {
              // Menghapus elemen terkait dengan ID khusus
              g.selectAll(
                `.marker-${attackId}, .pulse-${attackId}, .line-${attackId}`
              ).remove();
              marker = null;
              startPulseAnimation = false;
            }
          });
        });
      }

      function animateCountUpdate(element, newValue) {
        const currentValue = parseInt(element.innerText);

        // Buat container untuk animasi
        const container = document.createElement("div");
        container.style.position = "relative";
        container.style.display = "inline-block";
        container.style.height = element.offsetHeight + "px"; // Tetapkan tinggi container agar tetap konsisten

        // Elemen nilai lama
        const oldValueElement = document.createElement("div");
        oldValueElement.innerText = currentValue;
        oldValueElement.style.position = "absolute";
        oldValueElement.style.top = "0";
        oldValueElement.style.left = "0";
        oldValueElement.style.fontSize = "24px";
        oldValueElement.style.fontWeight = "bold";
        container.appendChild(oldValueElement);

        // Elemen nilai baru
        const newValueElement = document.createElement("div");
        newValueElement.innerText = newValue;
        newValueElement.style.position = "absolute";
        newValueElement.style.top = "0";
        newValueElement.style.left = "0";
        newValueElement.style.fontSize = "24px";
        newValueElement.style.fontWeight = "bold";
        newValueElement.style.opacity = "0";
        container.appendChild(newValueElement);

        // Ganti elemen asli dengan container yang di-animasi
        element.innerHTML = "";
        element.appendChild(container);

        anime({
          targets: oldValueElement,
          translateY: -50,
          duration: 500,
          easing: "easeInOutQuad",
          complete: () => {
            oldValueElement.remove();
          },
        });

        anime({
          targets: newValueElement,
          opacity: [0, 1],
          translateY: [50, 0],
          duration: 500,
          easing: "easeInOutQuad",
          complete: () => {
            // Setelah animasi selesai, reset posisi elemen agar sesuai
            newValueElement.style.position = "static";
            container.style.height = "auto"; // Hapus tinggi tetap dari container setelah animasi
          },
        });
      }
      let countOnGoing = [];
      // Fungsi untuk menghitung dan memperbarui jumlah On-going Attack
      function updateOngoingAttackCount() {
        // Ambil koleksi DDoSAttack dari Firestore
        const ddosAttackCollection = collection(db, "DDoSAttack");

        // Hitung jumlah record "On-going"
        onSnapshot(ddosAttackCollection, (snapshot) => {
          snapshot.docChanges().forEach((change) => {
            const currentTime = dayjs().utcOffset(7).toDate();
            const data = { id: change.doc.id, ...change.doc.data() };
            console.log({ countOnGoing });

            if (
              (data.Status === "On-going" ||
                (data.EndTime &&
                  timestampToDate(data.EndTime) > currentTime)) &&
              !countOnGoing.includes(data.id)
            ) {
              // Perbarui nilai pada elemen <h3>
              animateCountUpdate(
                document.getElementById("ongoing-attack-count"),
                onGoingRedAttack.length + onGoingYellowAttack.length
              );
              countOnGoing.push(data.id);
              console.log("halo");
            } else {
              if (
                !(
                  data.Status === "On-going" ||
                  (data.EndTime && timestampToDate(data.EndTime) > currentTime)
                ) &&
                countOnGoing.includes(data.id)
              ) {
                // Perbarui nilai pada elemen <h3>
                animateCountUpdate(
                  document.getElementById("ongoing-attack-count"),
                  onGoingRedAttack.length + onGoingYellowAttack.length
                );
                countOnGoing = countOnGoing.filter((item) => item !== data.id);
              }
            }
            console.log({ last: countOnGoing });
          });
        });
      }

      let countRedSeverity = [];
      function updateRedSeverityOngoingAttackCount() {
        // Ambil koleksi DDoSAttack dari Firestore
        const ddosAttackCollection = collection(db, "DDoSAttack");

        // Hitung jumlah record "On-going"
        onSnapshot(ddosAttackCollection, (snapshot) => {
          snapshot.docChanges().forEach((change) => {
            const currentTime = dayjs().utcOffset(7).toDate();
            const data = { id: change.doc.id, ...change.doc.data() };

            if (
              (data.Status === "On-going" ||
                (data.EndTime &&
                  timestampToDate(data.EndTime) > currentTime)) &&
              data.Severity.includes("red /") &&
              !countRedSeverity.includes(data.id)
            ) {
              // Perbarui nilai pada elemen <h3>
              animateCountUpdate(
                document.getElementById("ongoing-attack-count-red"),
                onGoingRedAttack.length
              );
              countRedSeverity.push(data.id);
            } else {
              if (
                !(
                  data.Status === "On-going" ||
                  (data.EndTime && timestampToDate(data.EndTime) > currentTime)
                ) &&
                data.Severity.includes("red /") &&
                countRedSeverity.includes(data.id)
              ) {
                // Perbarui nilai pada elemen <h3>
                animateCountUpdate(
                  document.getElementById("ongoing-attack-count-red"),
                  onGoingRedAttack.length
                );
                countRedSeverity = countRedSeverity.filter(
                  (item) => item !== data.id
                );
              }
            }
          });
        });
      }
      let countYellowSeverity = [];
      function updateYellowSeverityOngoingAttackCount() {
        // Ambil koleksi DDoSAttack dari Firestore
        const ddosAttackCollection = collection(db, "DDoSAttack");

        // Hitung jumlah record "On-going"
        onSnapshot(ddosAttackCollection, (snapshot) => {
          snapshot.docChanges().forEach((change) => {
            const currentTime = dayjs().utcOffset(7).toDate();
            const data = { id: change.doc.id, ...change.doc.data() };

            if (
              (data.Status === "On-going" ||
                (data.EndTime &&
                  timestampToDate(data.EndTime) > currentTime)) &&
              data.Severity.includes("yellow /") &&
              !countYellowSeverity.includes(data.id)
            ) {
              // Perbarui nilai pada elemen <h3>
              animateCountUpdate(
                document.getElementById("ongoing-attack-count-yellow"),
                onGoingYellowAttack.length
              );
              countYellowSeverity.push(data.id);
            } else {
              if (
                !(
                  data.Status === "On-going" ||
                  (data.EndTime && timestampToDate(data.EndTime) > currentTime)
                ) &&
                data.Severity.includes("yellow /") &&
                countYellowSeverity.includes(data.id)
              ) {
                // Perbarui nilai pada elemen <h3>
                animateCountUpdate(
                  document.getElementById("ongoing-attack-count-yellow"),
                  onGoingYellowAttack.length
                );
                countYellowSeverity = countYellowSeverity.filter(
                  (element) => element !== data.id
                );
              }
            }
          });
        });
      }

      function convertAverageBandwidth(bandwidth) {
        let returnVal;
        if (bandwidth / 1000000000 > 1) {
          returnVal = (bandwidth / 1000000000).toString() + " Gbps";
        } else if (bandwidth / 1000000 > 1) {
          returnVal = (bandwidth / 1000000).toString() + " Mbps";
        } else if (bandwidth / 1000 > 1) {
          returnVal = (bandwidth / 1000).toString() + " Kbps";
        } else {
          returnVal = bandwidth.toString() + " bps";
        }
        return returnVal;
      }

      function isIdInTopAttack(topAttack, id) {
        return topAttack.some((attack) => attack.id === id);
      }
      function updateTodoList(topAttack) {
        const idsInTopAttack = new Set(topAttack.map((attack) => attack.id));
        const existingItems = Array.from(todoList.children);
        const itemMap = new Map();

        // Buat peta ID ke elemen list
        existingItems.forEach((item) => {
          const id = item.dataset.id;
          if (id) {
            itemMap.set(id, item);
          }
        });
        // Tambahkan atau perbarui item dalam daftar
        topAttack.forEach((record) => {
          let listItem = itemMap.get(record.id);
          console.log(record);
          if (!listItem) {
            listItem = document.createElement("li");
            listItem.dataset.id = record.id; // Set ID di data attribute
            listItem.addEventListener("click", () => showModal(record));
          }

          // Set class dan innerHTML sesuai dengan severity
          if (record.Severity.includes("yellow /")) {
            listItem.className = "completed";
          } else if (record.Severity.includes("red /")) {
            listItem.className = "not-completed";
          }

          listItem.innerHTML = `<p><b>${
            record.VictimIp
          }</b> (${convertAverageBandwidth(
            record.AverageBandwidth
          )})</p><i class="bx bx-dots-vertical-rounded"></i>`;

          if (!listItem.parentNode) {
            todoList.appendChild(listItem);
          }

          // Update itemMap
          itemMap.set(record.id, listItem);
        });

        // Hapus item yang tidak lagi ada di topAttack
        existingItems.forEach((item) => {
          const id = item.dataset.id;
          if (!idsInTopAttack.has(id)) {
            todoList.removeChild(item);
            itemMap.delete(id);
          }
        });

        // Urutkan item dalam daftar sesuai dengan topAttack
        Array.from(todoList.children)
          .sort((a, b) => {
            const idA = a.dataset.id;
            const idB = b.dataset.id;
            const attackA = topAttack.find((attack) => attack.id === idA);
            const attackB = topAttack.find((attack) => attack.id === idB);

            return attackB.AverageBandwidth - attackA.AverageBandwidth;
          })
          .forEach((item) => {
            todoList.appendChild(item); // Menempatkan item di urutan yang benar
          });
      }

      const todoList = document.querySelector(".todo-list");
      const itemMap = new Map(); // Map untuk menyimpan referensi item berdasarkan ID

      function showModal(record) {
        document.getElementById("modal-id").textContent = record.id;
        document.getElementById("modal-chk").textContent = record.CHK;
        document.getElementById("modal-direction").textContent =
          record.Direction;
        document.getElementById("modal-resource").textContent = record.Resource;
        document.getElementById("modal-severity").textContent = record.Severity;
        document.getElementById("modal-starttime").textContent =
          record.StartTime.toDate().toLocaleString();
        document.getElementById("modal-type").textContent = record.Type;
        document.getElementById("modal-victimip").textContent = record.VictimIp;
        let temp = "";
        for (let i = 0; i < record.sourceIp.length; i++) {
          temp += `<li>${record.sourceIp[i]}</li>`;
        }
        document.getElementById("modal-sourceip").innerHTML = temp;
        new bootstrap.Modal(document.getElementById("recordModal")).show();
      }

      function formatData(data) {
        let avgBandwidth = data.Severity.split(" / ")[1];
        let avgBandwidthArr = avgBandwidth.split(" ");
        let avgBandwidthKiri = avgBandwidthArr[0];
        let avgBandwidthKanan = avgBandwidthArr[1];
        let pengali = 1;
        if (avgBandwidthKiri.includes("bps")) {
          avgBandwidthKiri = avgBandwidthKiri.replace("bps", "");
          console.log(avgBandwidthKiri);

          if (avgBandwidthKiri.includes("G")) {
            pengali = 1000000000;
            avgBandwidthKiri = avgBandwidthKiri.replace("G", "");
            avgBandwidthKiri = parseFloat(avgBandwidthKiri);
          } else if (avgBandwidthKiri.includes("M")) {
            pengali = 1000000;
            avgBandwidthKiri = avgBandwidthKiri.replace("M", "");
            avgBandwidthKiri = parseFloat(avgBandwidthKiri);
          } else if (avgBandwidthKiri.includes("K")) {
            pengali = 1000;
            avgBandwidthKiri = avgBandwidthKiri.replace("K", "");
            avgBandwidthKiri = parseFloat(avgBandwidthKiri);
          } else {
            avgBandwidthKiri = parseFloat(avgBandwidthKiri);
          }
          return { ...data, AverageBandwidth: avgBandwidthKiri * pengali };
        } else {
          avgBandwidthKanan = avgBandwidthKanan.replace("bps", "");
          avgBandwidthKanan = avgBandwidthKanan.replace("(", "");
          avgBandwidthKanan = avgBandwidthKanan.replace(")", "");

          console.log(avgBandwidthKanan);

          if (avgBandwidthKanan.includes("G")) {
            pengali = 1000000000;
            avgBandwidthKanan = avgBandwidthKanan.replace("G", "");
            avgBandwidthKanan = parseFloat(avgBandwidthKanan);
          } else if (avgBandwidthKanan.includes("M")) {
            pengali = 1000000;
            avgBandwidthKanan = avgBandwidthKanan.replace("M", "");
            avgBandwidthKanan = parseFloat(avgBandwidthKanan);
          } else if (avgBandwidthKanan.includes("K")) {
            pengali = 1000;
            avgBandwidthKanan = avgBandwidthKanan.replace("K", "");
            avgBandwidthKanan = parseFloat(avgBandwidthKanan);
          } else {
            avgBandwidthKanan = parseFloat(avgBandwidthKanan);
          }
          return { ...data, AverageBandwidth: avgBandwidthKanan * pengali };
        }
      }

      function updateTopAttack(topAttack, newAttack) {
        // Ambil currentTime dalam Waktu Indonesia Barat (WIB)
        const currentTimeWIB = new Date(
          new Date().toLocaleString("en-US", { timeZone: "Asia/Jakarta" })
        );
        const currentDay = currentTimeWIB.getDate();
        const currentMonth = currentTimeWIB.getMonth();
        const currentYear = currentTimeWIB.getFullYear();

        // Cek apakah newAttack sudah ada di dalam topAttack berdasarkan id
        const attackExists = topAttack.some(
          (attack) => attack.id === newAttack.id
        );

        // Jika object tidak ada dalam topAttack
        if (!attackExists) {
          // Konversi StartTime dari Firebase timestamp menjadi objek Date
          const startTimeInMillis =
            newAttack.StartTime.seconds * 1000 +
            newAttack.StartTime.nanoseconds / 1000000;
          const startTime = new Date(startTimeInMillis);

          // Cek apakah StartTime berada pada hari yang sama dengan currentTime (WIB)
          const isSameDay =
            startTime.getDate() === currentDay &&
            startTime.getMonth() === currentMonth &&
            startTime.getFullYear() === currentYear;

          if (isSameDay) {
            // Masukkan object ke dalam array pada posisi yang sesuai
            let inserted = false;
            for (let i = 0; i < topAttack.length; i++) {
              if (newAttack.AverageBandwidth > topAttack[i].AverageBandwidth) {
                topAttack.splice(i, 0, newAttack);
                inserted = true;
                break;
              }
            }

            // Jika tidak ada object yang lebih besar, push ke akhir array
            if (!inserted) {
              topAttack.push(newAttack);
            }

            // Batasi topAttack menjadi hanya 10 object terbesar
            if (topAttack.length > 10) {
              topAttack.pop();
            }
          }
        }
        // filter dulu top attack sebelum return
        topAttack = topAttack.filter((item) => {
          const startTimeInMillis1 =
            item.StartTime.seconds * 1000 +
            item.StartTime.nanoseconds / 1000000;
          const startTime1 = new Date(startTimeInMillis1);
          return (
            startTime1.getDate() === currentDay &&
            startTime1.getMonth() === currentMonth &&
            startTime1.getFullYear() === currentYear
          );
        });

        return topAttack;
      }

      let topAttack = [];
      // Fungsi untuk memulai listener untuk perubahan data secara real-time
      function listenToDDoSAttacks() {
        const ddosAttackCollection = collection(db, "DDoSAttack");
        // Memulai listener untuk memantau perubahan
        onSnapshot(ddosAttackCollection, (snapshot) => {
          snapshot.docChanges().forEach((change) => {
            if (change.type === "added") {
              const newAttackData = { id: change.doc.id, ...change.doc.data() };
              const formatedData = formatData(newAttackData);
              topAttack = updateTopAttack(topAttack, formatedData);
              console.log(topAttack);
              updateTodoList(topAttack);
              if (
                newAttackData.Status === "On-going" &&
                !(
                  onGoingRedAttack.includes(newAttackData.id) ||
                  onGoingYellowAttack.includes(newAttackData.id)
                )
              ) {
                renderMarkerByStatus(newAttackData);
              } else {
                if (
                  !(
                    onGoingRedAttack.includes(newAttackData.id) ||
                    onGoingYellowAttack.includes(newAttackData.id)
                  )
                ) {
                  renderMarkerByEndTime(newAttackData);
                }
              }
              addOnGoingAttack(newAttackData);
            }
            if (change.type === "modified") {
              const newAttackData = { id: change.doc.id, ...change.doc.data() };
              const formatedData = formatData(newAttackData);
              topAttack = updateTopAttack(topAttack, formatedData);
              console.log({ onGoingRedAttack, onGoingYellowAttack });
              updateTodoList(topAttack);
              if (
                newAttackData.Status === "On-going" &&
                !(
                  onGoingRedAttack.includes(newAttackData.id) ||
                  onGoingYellowAttack.includes(newAttackData.id)
                )
              ) {
                renderMarkerByStatus(newAttackData);
              } else {
                if (
                  !(
                    onGoingRedAttack.includes(newAttackData.id) ||
                    onGoingYellowAttack.includes(newAttackData.id)
                  )
                ) {
                  renderMarkerByEndTime(newAttackData);
                }
              }
              addOnGoingAttack(newAttackData);
              removeOnGoingAttack(newAttackData);
              console.log({ onGoingRedAttack, onGoingYellowAttack });
              console.log("Modified data: ", change.doc.data());
            }
            if (change.type === "removed") {
              const removedAttackdata = {
                id: change.doc.id,
                ...change.doc.data(),
              };
              const formatedData = formatData(removedAttackdata);
              topAttack = updateTopAttack(topAttack, formatedData);
              updateTodoList(topAttack);
              console.log("Removed data: ", change.doc.data());
              const removedItem = itemMap.get(change.doc.id);
              if (removedItem) {
                todoList.removeChild(removedItem);
                itemMap.delete(change.doc.id);
              }
              removeOnGoingAttack(removedAttackdata);
            }
          });
        });
      }

      // Panggil fungsi untuk memulai listener
      listenToDDoSAttacks();
      updateOngoingAttackCount();
      updateRedSeverityOngoingAttackCount();
      updateYellowSeverityOngoingAttackCount();

      // TOOLTIP
      // Dapatkan referensi ke tooltip
      const tooltip = select("#tooltip");

      // Fungsi untuk menampilkan tooltip
      function showTooltip(event, data) {
        tooltip
          .style("left", `${event.pageX + 10}px`) // Posisi tooltip sedikit offset dari kursor
          .style("top", `${event.pageY + 10}px`)
          .style("display", "block")
          .style("background-color", "#060714") // Background berwarna #060714
          .style("color", "white") // Teks berwarna putih
          .html(`
        <strong>Resource:</strong> ${data.Resource}<br>
        <strong>Type:</strong> ${data.Type}<br>
        <strong>Victim IP:</strong> ${data.VictimIp}<br>
        <strong>Start Time:</strong> ${dayjs(data.StartTime.toDate()).format(
          "YYYY-MM-DD HH:mm:ss"
        )}
      `);
      }

      // Fungsi untuk menyembunyikan tooltip
      function hideTooltip() {
        tooltip.style("display", "none");
      }

      // Kode untuk memuat peta dan melakukan setup D3.js
      const svg = select("svg");

      const width = parseFloat(svg.style("width"));
      const height = parseFloat(svg.style("height"));

      const projection = geoNaturalEarth1()
        .scale(250)
        .translate([width / 2, height / 2]);

      const pathGenerator = geoPath().projection(projection);

      const g = svg.append("g"); // Grup yang akan digunakan untuk zoom dan panning

      // Tambahkan sphere ke dalam grup `g`
      g.append("path")
        .attr("d", pathGenerator({ type: "Sphere" }))
        .attr("fill", "black");

      svg.call(
        zoom()
          .scaleExtent([1, 8])
          .on("zoom", (event) => {
            g.attr("transform", event.transform);
          })
      );

      json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json")
        .then((data) => {
          const countries = topojson.feature(data, data.objects.countries);

          g.selectAll("path")
            .data(countries.features)
            .enter()
            .append("path")
            .attr("class", "land")
            .attr("d", pathGenerator)
            .append("title")
            .text((d) => d.properties.name || "Unknown");
        })
        .catch((error) => console.error("Error fetching map data:", error));

      // Kode untuk menu dan resize event
      const allSideMenu = document.querySelectorAll(
        "#sidebar .side-menu.top li a"
      );

      allSideMenu.forEach((item) => {
        const li = item.parentElement;

        item.addEventListener("click", function () {
          allSideMenu.forEach((i) => {
            i.parentElement.classList.remove("active");
          });
          li.classList.add("active");
        });
      });

      window.addEventListener("resize", function () {
        if (this.innerWidth > 576) {
          searchButtonIcon.classList.replace("bx-x", "bx-search");
          searchForm.classList.remove("show");
        }
      });
    </script>
  </body>
</html>
