<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Boxicons -->
    <link
      href="https://unpkg.com/boxicons@2.0.9/css/boxicons.min.css"
      rel="stylesheet"
    />
    <!-- My CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="style.css" />
    <link rel="icon" href="./img/logoTelkom.png" type="image/x-icon" />
    <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
    <title>DDoS Threat Map</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css"
      integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />
    <style>
      #map-container {
        width: 75vw;
        height: 75vh;
        padding: 10px;
        background-color: #060714;
        border-radius: 15px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        border: 1px solid #ddd;
        margin-left: 12.25vw;
        margin-top: 10vh;
      }

      svg {
        width: 100%;
        height: 100%;
        border-radius: 10px;
      }

      .land {
        fill: grey;
        stroke: #333;
        stroke-width: 0.5px;
      }

      .land:hover {
        fill: blue;
      }

      .markerRed {
        fill: red;
        stroke: black;
        stroke-width: 1px;
      }
      .markerYellow {
        fill: yellow;
        stroke: black;
        stroke-width: 1px;
      }

      .pulseRed {
        fill: none;
        stroke: red;
        stroke-width: 2px;
        opacity: 0.7;
      }
      .pulseYellow {
        fill: none;
        stroke: yellow;
        stroke-width: 2px;
        opacity: 0.7;
      }
      .modal-content {
        background-color: #1e1e1e;
        color: white;
      }

      .modal-header {
        border-bottom: 1px solid #444;
      }

      .modal-footer {
        border-top: 1px solid #444;
      }

      .lineRed {
        fill: none;
        stroke: red;
        stroke-width: 2px;
        opacity: 0.7;
      }
      .lineYellow {
        fill: none;
        stroke: yellow;
        stroke-width: 2px;
        opacity: 0.7;
      }
    </style>
  </head>
  <body class="dark">
    <!-- NAVBAR -->
    <nav>
      <img src="./img/logoTelkom.png" id="logo" />
    </nav>
    <!-- NAVBAR -->

    <!-- MAIN -->
    <main>
      <ul class="box-info">
        <li>
          <i class="fa-solid fa-land-mine-on fa-2xl" style="color: #74c0fc"></i>
          <span class="text">
            <h3 id="ongoing-attack-count">0</h3>
            <p>On-going Attack</p>
          </span>
        </li>
        <li>
          <i
            class="fa-solid fa-triangle-exclamation fa-2xl"
            style="color: #ff0000"
          ></i>
          <span class="text">
            <h3 id="ongoing-attack-count-red">0</h3>
            <p>Red Severity On-going Attack</p>
          </span>
        </li>
        <li>
          <i
            class="fa-solid fa-triangle-exclamation fa-2xl"
            style="color: #ffd43b"
          ></i>
          <span class="text">
            <h3 id="ongoing-attack-count-yellow">0</h3>
            <p>Yellow Severity On-going Attack</p>
          </span>
        </li>
      </ul>
      <div id="map-container">
        <svg></svg>
      </div>

      <div class="table-data">
        <div class="todo">
          <div class="head">
            <h3>Top Attack Duration In Current Month</h3>
          </div>
          <ul class="todo-list"></ul>
        </div>
        <div class="todo">
          <div class="head">
            <h3>Top Ongoing Attack Duration</h3>
          </div>
          <ul class="ongoing-todo-list"></ul>
        </div>
      </div>
    </main>
    <!-- MAIN -->

    <!-- Modal HTML -->
    <div
      class="modal fade"
      id="recordModal"
      tabindex="-1"
      aria-labelledby="recordModalLabel"
      aria-hidden="true"
    >
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="recordModalLabel">Attack Details</h5>
            <button
              type="button"
              class="btn-close"
              data-bs-dismiss="modal"
              aria-label="Close"
            ></button>
          </div>
          <div class="modal-body" id="modal-body">
            <p><strong>Anomaly ID:</strong> <span id="modal-id"></span></p>
            <p>
              <strong>Creation Time:</strong>
              <span id="modal-creationtime"></span>
            </p>
            <p>
              <strong>Update Time:</strong> <span id="modal-updatetime"></span>
            </p>
            <p><strong>Type:</strong> <span id="modal-type"></span></p>
            <p><strong>Sub-type:</strong> <span id="modal-subtype"></span></p>
            <p><strong>Scope:</strong> <span id="modal-scope"></span></p>
            <p><strong>Severity:</strong> <span id="modal-severity"></span></p>
            <p><strong>Status:</strong> <span id="modal-status"></span></p>
            <p>
              <strong>Direction:</strong> <span id="modal-direction"></span>
            </p>
            <p><strong>Resource:</strong> <span id="modal-resource"></span></p>
            <p>
              <strong>Resource ID:</strong> <span id="modal-resourceid"></span>
            </p>
            <p>
              <strong>Importance:</strong> <span id="modal-importance"></span>
            </p>
            <p>
              <strong>Triggered Value:</strong>
              <span id="modal-triggeredvalue"></span>
            </p>
            <p>
              <strong>Threshold:</strong> <span id="modal-threshold"></span>
            </p>
            <p><strong>Unit:</strong> <span id="modal-unit"></span></p>
            <p>
              <strong>Anomaly Host IP:</strong>
              <span id="modal-anomalyip"></span>
            </p>
            <p><strong>SIP1:</strong> <span id="modal-sip1"></span></p>
            <p><strong>SIP2:</strong> <span id="modal-sip2"></span></p>
            <p><strong>SIP3:</strong> <span id="modal-sip3"></span></p>
            <p><strong>SPort1:</strong> <span id="modal-sport1"></span></p>
            <p><strong>SPort2:</strong> <span id="modal-sport2"></span></p>
            <p><strong>Protocol:</strong> <span id="modal-protocol"></span></p>
            <p>
              <strong>URL to Link the Report:</strong>
              <span id="modal-url"></span>
            </p>
            <p><strong>Remarks:</strong> <span id="modal-remarks"></span></p>
            <p>
              <strong>Attack Direction:</strong>
              <span id="modal-attackdirection"></span>
            </p>

            <!-- Move ul outside of the p tag -->
            <p><strong>Source IP:</strong></p>
            <ul id="modal-sourceip"></ul>

            <p>
              <strong>StartTime:</strong> <span id="modal-starttime"></span>
            </p>
          </div>
          <div class="modal-footer">
            <button
              type="button"
              class="btn btn-secondary"
              data-bs-dismiss="modal"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- TOOLTIP -->
    <div
      id="tooltip"
      style="
        position: absolute;
        background: #fff;
        border: 1px solid #ddd;
        padding: 5px;
        border-radius: 3px;
        pointer-events: none;
        display: none;
      "
    ></div>
    <!-- JavaScript SDK -->
    <script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"
      integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js"
      integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy"
      crossorigin="anonymous"
    ></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <script type="module">
      import {
        select,
        json,
        geoPath,
        geoNaturalEarth1,
        zoom,
        easeCubicInOut,
      } from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
      import { feature } from "https://cdn.jsdelivr.net/npm/topojson@3/+esm";
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.0.0/firebase-app.js";
      import {
        getFirestore,
        collection,
        onSnapshot,
        Timestamp,
        doc,
        updateDoc,
        getDocs,
      } from "https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore.js";
      import dayjs from "https://cdn.jsdelivr.net/npm/dayjs@1.10.4/+esm";
      import utc from "https://cdn.jsdelivr.net/npm/dayjs@1.10.4/plugin/utc/+esm";
      import anime from "https://cdn.jsdelivr.net/npm/animejs@3.2.1/+esm";

      dayjs.extend(utc);

      const ws = new WebSocket("ws:/localhost:8080");
      const ipInfoToken = "IP INFO TOKEN";

      let onGoingYellowAttack = [];
      let onGoingRedAttack = [];

      function addOnGoingAttack(data) {
        const currentTime = dayjs().utcOffset(7).toDate();
        // cek apakah dia memenuhi syarat on-gooing
        if (
          data.Status === "Ongoing" ||
          (data.EndTime && timestampToDate(data.EndTime) > currentTime)
        ) {
          // jika memenuhi, cek apakah dia merupakan red severity
          if (data.Severity.includes("Red")) {
            // jika iya, cek apakah id nya ada di onGoingRedAttack
            if (!onGoingRedAttack.includes(data.id)) {
              // jika tidak ada, push ke array onGoingRedAttack
              onGoingRedAttack.push(data.id);
            }
          } else {
            //  lakukan hal yang sama pada yellow attack
            if (!onGoingYellowAttack.includes(data.id)) {
              onGoingYellowAttack.push(data.id);
            }
          }
        }
      }

      function removeOnGoingAttack(data) {
        const currentTime = dayjs().utcOffset(7).toDate();
        // cek apakah data memenuhi syarat Ongoing
        if (
          !(
            data.Status === "Ongoing" ||
            (data.EndTime && timestampToDate(data.EndTime) > currentTime)
          )
        ) {
          // jika tidak memenuhi, cek apakah dia merupakan red severity
          if (data.Severity.includes("Red")) {
            // jika merupakan red severity, cek apakah dia ada di dalam onGoingRedAttack
            if (onGoingRedAttack.includes(data.id)) {
              // jika ada, filter array sehingga tidak ada nilai tersebut (hapus id data tersebut dari onGoingRedAttack)
              onGoingRedAttack = onGoingRedAttack.filter(
                (item) => item !== data.id
              );
            }
          } else {
            // lakukan hal yang sama pada yellow severity attack
            if (onGoingYellowAttack.includes(data.id)) {
              onGoingYellowAttack = onGoingYellowAttack.filter(
                (item) => item !== data.id
              );
            }
          }
        }
      }

      // Fungsi untuk mengonversi Timestamp ke Date
      function timestampToDate(timestamp) {
        return timestamp.toDate();
      }

      function removeAttackById(attackId) {
        // Menghapus marker berdasarkan attackId
        d3.selectAll(`.marker-${escapeIPForSelector(attackId)}`).remove();

        // Menghapus animasi pulse berdasarkan attackId
        d3.selectAll(`.pulse-${escapeIPForSelector(attackId)}`).remove();

        // Menghapus animasi garis berdasarkan attackId
        d3.selectAll(`.line-${escapeIPForSelector(attackId)}`).remove();
      }

      function escapeIPForSelector(ip) {
        return ip.replace(/\./g, "-");
      }

      function isAttackOnGoing(newAttack) {
        return (
          onGoingYellowAttack.some(
            (attack) =>
              attack["Anomaly Host IP"] === newAttack["Anomaly Host IP"]
          ) ||
          onGoingRedAttack.some(
            (attack) =>
              attack["Anomaly Host IP"] === newAttack["Anomaly Host IP"]
          )
        );
      }

      function renderMarkerByStatus(el) {
        const sourceIP = el.sourceIp;
        const destinationIP = el.VictimIp;
        const attackId = el.VictimIp;
        let startPulseAnimation, marker;

        const getGeoLocation = (ip) =>
          fetch(`https://ipinfo.io/${ip}/geo?token=${ipInfoToken}`).then(
            (response) => response.json()
          );

        const getArrayGeolocation = (ips) => {
          const promises = ips.map((ip) =>
            fetch(`https://ipinfo.io/${ip}/geo?token=${ipInfoToken}`).then(
              (response) => response.json()
            )
          );
          return Promise.all(promises);
        };

        Promise.all([
          getArrayGeolocation(sourceIP),
          getGeoLocation(destinationIP),
        ]).then((locations) => {
          const [sourceData, destinationData] = locations;

          let sourceCoords = [];
          sourceData.forEach((el) => {
            let [sourceLat, sourceLon] = el.loc.split(",");
            let sourceCoord = projection([sourceLon, sourceLat]);
            sourceCoords.push(sourceCoord);
          });

          const [destLat, destLon] = destinationData.loc.split(",");
          const destCoords = projection([destLon, destLat]);

          g.append("circle")
            .attr("cx", destCoords[0])
            .attr("cy", destCoords[1])
            .attr("r", 5)
            .attr("class", `marker marker-${escapeIPForSelector(attackId)}`) // Menambahkan kelas khusus dengan ID
            .append("title")
            .text(`${destinationData.city}, ${destinationData.country}`);

          function createPulse(className) {
            const pulse = g
              .append("circle")
              .attr(
                "class",
                `${className} pulse-${escapeIPForSelector(attackId)}`
              ) // Menambahkan kelas khusus dengan ID
              .attr("cx", destCoords[0])
              .attr("cy", destCoords[1])
              .attr("r", 5)
              .attr("opacity", 0.7);

            let radiusEnd = className === "pulseRed" ? 25 : 15;

            pulse
              .transition()
              .duration(1500)
              .ease(d3.easeCubicInOut)
              .attr("r", radiusEnd)
              .attr("opacity", 0)
              .on("end", () => {
                pulse.remove();
                if (isAttackOnGoing(el) && marker && !marker.empty()) {
                  createPulse(className);
                }
              });
          }

          let idx = 0;

          function drawLine(className) {
            const lineGenerator = d3
              .line()
              .x((d) => d[0])
              .y((d) => d[1])
              .curve(d3.curveBasis);

            const points = [
              [sourceCoords[idx][0], sourceCoords[idx][1]],
              [
                (sourceCoords[idx][0] + destCoords[0]) / 2,
                sourceCoords[idx][1] - 100,
              ],
              [destCoords[0], destCoords[1]],
            ];

            const path = g
              .append("path")
              .attr("d", lineGenerator(points))
              .attr(
                "class",
                `${className} line-${escapeIPForSelector(attackId)}`
              ); // Menambahkan kelas khusus dengan ID

            const totalLength = path.node().getTotalLength();

            path
              .attr("stroke-dasharray", totalLength + " " + totalLength)
              .attr("stroke-dashoffset", totalLength)
              .transition()
              .duration(2000)
              .ease(d3.easeCubicInOut)
              .attr("stroke-dashoffset", 0)
              .remove()
              .on("end", () => {
                if (isAttackOnGoing(el) && marker && !marker.empty()) {
                  idx++;
                  if (idx >= sourceCoords.length) {
                    idx = 0;
                  }
                  drawLine(className);
                }
              });
          }

          function createMarker(className) {
            marker = g
              .append("circle")
              .attr(
                "class",
                `${className} marker-${escapeIPForSelector(attackId)}`
              ) // Menambahkan kelas khusus dengan ID
              .attr("cx", destCoords[0])
              .attr("cy", destCoords[1])
              .attr("r", 5)
              .on("mouseover", (event) => showTooltip(event, el))
              .on("mouseout", hideTooltip);

            startPulseAnimation = true;
            createPulse(className === "markerRed" ? "pulseRed" : "pulseYellow");
            drawLine(className === "markerRed" ? "lineRed" : "lineYellow");
          }

          if (el.Status === "Ongoing") {
            createMarker(
              el.Severity.includes("Red") ? "markerRed" : "markerYellow"
            );
          }
        });
      }

      function animateCountUpdate(element, newValue) {
        const currentValue = parseInt(element.innerText);

        // Buat container untuk animasi
        const container = document.createElement("div");
        container.style.position = "relative";
        container.style.display = "inline-block";
        container.style.height = element.offsetHeight + "px"; // Tetapkan tinggi container agar tetap konsisten

        // Elemen nilai lama
        const oldValueElement = document.createElement("div");
        oldValueElement.innerText = currentValue;
        oldValueElement.style.position = "absolute";
        oldValueElement.style.top = "0";
        oldValueElement.style.left = "0";
        oldValueElement.style.fontSize = "24px";
        oldValueElement.style.fontWeight = "bold";
        container.appendChild(oldValueElement);

        // Elemen nilai baru
        const newValueElement = document.createElement("div");
        newValueElement.innerText = newValue;
        newValueElement.style.position = "absolute";
        newValueElement.style.top = "0";
        newValueElement.style.left = "0";
        newValueElement.style.fontSize = "24px";
        newValueElement.style.fontWeight = "bold";
        newValueElement.style.opacity = "0";
        container.appendChild(newValueElement);

        // Ganti elemen asli dengan container yang di-animasi
        element.innerHTML = "";
        element.appendChild(container);

        anime({
          targets: oldValueElement,
          translateY: -50,
          duration: 500,
          easing: "easeInOutQuad",
          complete: () => {
            oldValueElement.remove();
          },
        });

        anime({
          targets: newValueElement,
          opacity: [0, 1],
          translateY: [50, 0],
          duration: 500,
          easing: "easeInOutQuad",
          complete: () => {
            // Setelah animasi selesai, reset posisi elemen agar sesuai
            newValueElement.style.position = "static";
            container.style.height = "auto"; // Hapus tinggi tetap dari container setelah animasi
          },
        });
      }
      let countOnGoing = [];
      // Fungsi untuk menghitung dan memperbarui jumlah Ongoing Attack
      function updateOngoingAttackCount(data) {
        // cek apakah serangan sudah ada di dalam countOnGoing (berdasarkan sourceIp dan destinationIp)
        const newDestIp = data["Anomaly Host IP"];
        const include = countOnGoing.some((item) => item.destIp == newDestIp);
        if (data.Status === "Ongoing" && !include) {
          // Perbarui nilai pada elemen <h3>
          countOnGoing.push({ destIp: newDestIp });
          animateCountUpdate(
            document.getElementById("ongoing-attack-count"),
            onGoingRedAttack.length + onGoingYellowAttack.length
          );
        } else {
          if (!data.Status !== "Ongoing" && include) {
            // Perbarui nilai pada elemen <h3>
            countOnGoing = countOnGoing.filter(
              (item) => item.destIp !== newDestIp
            );
            animateCountUpdate(
              document.getElementById("ongoing-attack-count"),
              onGoingRedAttack.length + onGoingYellowAttack.length
            );
          }
        }
      }

      let countRedSeverity = [];
      function updateRedSeverityOngoingAttackCount(data) {
        // cek apakah serangan sudah ada di dalam countOnGoing (berdasarkan sourceIp dan destinationIp)
        const newDestIp = data["Anomaly Host IP"];
        const include = countRedSeverity.some(
          (item) => item.destIp == newDestIp
        );
        if (data.Status === "Ongoing" && !include) {
          // Perbarui nilai pada elemen <h3>
          countRedSeverity.push({ destIp: newDestIp });
          animateCountUpdate(
            document.getElementById("ongoing-attack-count-red"),
            onGoingRedAttack.length
          );
        } else {
          if (!data.Status !== "Ongoing" && include) {
            // Perbarui nilai pada elemen <h3>
            countRedSeverity = countRedSeverity.filter(
              (item) => item.destIp !== newDestIp
            );
            animateCountUpdate(
              document.getElementById("ongoing-attack-count-red"),
              onGoingRedAttack.length
            );
          }
        }
      }
      let countYellowSeverity = [];
      function updateYellowSeverityOngoingAttackCount(data) {
        // cek apakah serangan sudah ada di dalam countOnGoing (berdasarkan sourceIp dan destinationIp)
        const newDestIp = data["Anomaly Host IP"];
        const include = countYellowSeverity.some(
          (item) => item.destIp == newDestIp
        );
        if (data.Status === "Ongoing" && !include) {
          // Perbarui nilai pada elemen <h3>
          countYellowSeverity.push({
            destIp: newDestIp,
          });
          animateCountUpdate(
            document.getElementById("ongoing-attack-count-yellow"),
            onGoingYellowAttack.length
          );
        } else {
          if (!data.Status !== "Ongoing" && include) {
            // Perbarui nilai pada elemen <h3>
            countYellowSeverity = countYellowSeverity.filter(
              (item) => item.destIp !== newDestIp
            );
            animateCountUpdate(
              document.getElementById("ongoing-attack-count-yellow"),
              onGoingYellowAttack.length
            );
          }
        }
      }

      function convertToStringTime(minutes) {
        const hours = Math.floor(minutes / 60); // Hitung jam
        const remainingMinutes = minutes % 60; // Hitung sisa menit setelah konversi ke jam

        // Buat string format "X jam Y menit"
        let result = "";
        if (hours > 0) {
          result += `${hours} jam `;
        }
        if (remainingMinutes > 0) {
          result += `${remainingMinutes} menit`;
        }

        // Jika waktu 0 menit, tampilkan "0 menit"
        if (result === "") {
          result = "0 menit";
        }

        return result.trim(); // Hapus spasi di awal/akhir string jika ada
      }

      function convertAverageBandwidth(bandwidth) {
        let returnVal;
        if (bandwidth / 1000000000 > 1) {
          returnVal = (bandwidth / 1000000000).toString() + " Gbps";
        } else if (bandwidth / 1000000 > 1) {
          returnVal = (bandwidth / 1000000).toString() + " Mbps";
        } else if (bandwidth / 1000 > 1) {
          returnVal = (bandwidth / 1000).toString() + " Kbps";
        } else {
          returnVal = bandwidth.toString() + " bps";
        }
        return returnVal;
      }

      function isIdInTopAttack(topAttack, id) {
        return topAttack.some((attack) => attack.id === id);
      }
      function updateTodoList(topAttack) {
        const idsInTopAttack = new Set(
          topAttack.map((attack) => `${attack["Anomaly Host IP"]}`)
        );
        const existingItems = Array.from(todoList.children);
        const itemMap = new Map();

        // Buat peta ID ke elemen list
        existingItems.forEach((item) => {
          const id = item.dataset.id;
          if (id) {
            itemMap.set(id, item);
          }
        });
        // Tambahkan atau perbarui item dalam daftar
        topAttack.forEach((record) => {
          let listItem = itemMap.get(`${record["Anomaly Host IP"]}`);
          if (!listItem) {
            listItem = document.createElement("li");
            listItem.dataset.id = `${record["Anomaly Host IP"]}`; // Set ID di data attribute
            listItem.addEventListener("click", () => showModal(record));
          }

          // Set class dan innerHTML sesuai dengan severity
          if (record.Severity.includes("Yellow")) {
            listItem.className = "completed";
          } else if (record.Severity.includes("Red")) {
            listItem.className = "not-completed";
          }

          listItem.innerHTML = `<p><b>${
            record.VictimIp
          }</b> (${convertToStringTime(
            record.Duration
          )})</p><i class="bx bx-dots-vertical-rounded"></i>`;

          if (!listItem.parentNode) {
            todoList.appendChild(listItem);
          }

          // Update itemMap
          itemMap.set(`${record["Anomaly Host IP"]}`, listItem);
        });

        // Hapus item yang tidak lagi ada di topAttack
        existingItems.forEach((item) => {
          const id = item.dataset.id;
          if (!idsInTopAttack.has(id)) {
            todoList.removeChild(item);
            itemMap.delete(id);
          }
        });

        // Urutkan item dalam daftar sesuai dengan topAttack
        Array.from(todoList.children)
          .sort((a, b) => {
            const idA = a.dataset.id;
            const idB = b.dataset.id;
            const attackA = topAttack.find(
              (attack) => attack.SIP + attack["Anomaly Host IP"] === idA
            );
            const attackB = topAttack.find(
              (attack) => attack.SIP + attack["Anomaly Host IP"] === idB
            );

            return attackB.Duration - attackA.Duration;
          })
          .forEach((item) => {
            todoList.appendChild(item); // Menempatkan item di urutan yang benar
          });
      }

      function updateOnGoingTodoList(topAttack) {
        const idsInTopAttack = new Set(
          topAttack.map((attack) => `${attack["Anomaly Host IP"]}`)
        );
        const existingItems = Array.from(onGoingTodoList.children);
        const itemMapOnGoing = new Map();

        // Buat peta ID ke elemen list
        existingItems.forEach((item) => {
          const id = item.dataset.id;
          if (id) {
            itemMapOnGoing.set(id, item);
          }
        });
        // Tambahkan atau perbarui item dalam daftar
        topAttack.forEach((record) => {
          let listItem = itemMapOnGoing.get(`${record["Anomaly Host IP"]}`);
          if (!listItem) {
            listItem = document.createElement("li");
            listItem.dataset.id = `${record["Anomaly Host IP"]}`; // Set ID di data attribute
            listItem.addEventListener("click", () => showModal(record));
          }

          // Set class dan innerHTML sesuai dengan severity
          if (record.Severity.includes("Yellow")) {
            listItem.className = "completed";
          } else if (record.Severity.includes("Red")) {
            listItem.className = "not-completed";
          }

          listItem.innerHTML = `<p><b>${
            record.VictimIp
          }</b> (${convertToStringTime(
            record.Duration
          )})</p><i class="bx bx-dots-vertical-rounded"></i>`;

          if (!listItem.parentNode) {
            onGoingTodoList.appendChild(listItem);
          }

          // Update itemMapOnGoing
          itemMapOnGoing.set(`${record["Anomaly Host IP"]}`, listItem);
        });

        // Hapus item yang tidak lagi ada di topAttack
        existingItems.forEach((item) => {
          const id = item.dataset.id;
          if (!idsInTopAttack.has(id)) {
            onGoingTodoList.removeChild(item);
            itemMapOnGoing.delete(id);
          }
        });

        // Urutkan item dalam daftar sesuai dengan topAttack
        Array.from(onGoingTodoList.children)
          .sort((a, b) => {
            const idA = a.dataset.id;
            const idB = b.dataset.id;
            const attackA = topAttack.find(
              (attack) => attack.SIP + attack["Anomaly Host IP"] === idA
            );
            const attackB = topAttack.find(
              (attack) => attack.SIP + attack["Anomaly Host IP"] === idB
            );

            return attackB.Duration - attackA.Duration;
          })
          .forEach((item) => {
            onGoingTodoList.appendChild(item);
          });
      }

      const todoList = document.querySelector(".todo-list");
      const onGoingTodoList = document.querySelector(".ongoing-todo-list");
      const itemMap = new Map(); // Map untuk menyimpan referensi item berdasarkan ID
      const itemMapOnGoing = new Map();

      function showModal(record) {
        // Set each field manually
        document.getElementById("modal-id").textContent = record["Anomaly ID"];
        document.getElementById("modal-creationtime").textContent =
          record["Creation Time"];
        document.getElementById("modal-updatetime").textContent =
          record["Update Time"];
        document.getElementById("modal-type").textContent = record["Type"];
        document.getElementById("modal-subtype").textContent =
          record["Sub-type"];
        document.getElementById("modal-scope").textContent = record["Scope"];
        document.getElementById("modal-severity").textContent =
          record["Severity"];
        document.getElementById("modal-status").textContent = record["Status"];
        document.getElementById("modal-direction").textContent =
          record["Direction"];
        document.getElementById("modal-resource").textContent =
          record["Resource"];
        document.getElementById("modal-resourceid").textContent =
          record["Resource ID"];
        document.getElementById("modal-importance").textContent =
          record["Importance"];
        document.getElementById("modal-triggeredvalue").textContent =
          record["Triggered Value"];
        document.getElementById("modal-threshold").textContent =
          record["Threshold"];
        document.getElementById("modal-unit").textContent = record["Unit"];
        document.getElementById("modal-anomalyip").textContent =
          record["Anomaly Host IP"];
        document.getElementById("modal-sip1").textContent = record["SIP1"];
        document.getElementById("modal-sip2").textContent = record["SIP2"];
        document.getElementById("modal-sip3").textContent = record["SIP3"];
        document.getElementById("modal-sport1").textContent = record["SPort1"];
        document.getElementById("modal-sport2").textContent = record["SPort2"];
        document.getElementById("modal-protocol").textContent =
          record["Protocol"];
        document.getElementById("modal-url").innerHTML =
          record["URL to Link the Report"];
        document.getElementById("modal-remarks").textContent =
          record["Remarks"];
        document.getElementById("modal-attackdirection").textContent =
          record["Attack Direction"];

        // Handle array for sourceIp
        let sourceIpList = "";
        for (let i = 0; i < record.sourceIp.length; i++) {
          sourceIpList += `<li>${record.sourceIp[i]}</li>`;
        }
        document.getElementById("modal-sourceip").innerHTML = sourceIpList;

        // Handle StartTime which is a Date object
        document.getElementById("modal-starttime").textContent =
          record.StartTime.toLocaleString();

        // Show the modal
        new bootstrap.Modal(document.getElementById("recordModal")).show();
      }

      function formatData(data) {
        let avgBandwidth = data.Severity.split(" / ")[1];
        let avgBandwidthArr = avgBandwidth.split(" ");
        let avgBandwidthKiri = avgBandwidthArr[0];
        let avgBandwidthKanan = avgBandwidthArr[1];
        let pengali = 1;
        if (avgBandwidthKiri.includes("bps")) {
          avgBandwidthKiri = avgBandwidthKiri.replace("bps", "");
          if (avgBandwidthKiri.includes("G")) {
            pengali = 1000000000;
            avgBandwidthKiri = avgBandwidthKiri.replace("G", "");
            avgBandwidthKiri = parseFloat(avgBandwidthKiri);
          } else if (avgBandwidthKiri.includes("M")) {
            pengali = 1000000;
            avgBandwidthKiri = avgBandwidthKiri.replace("M", "");
            avgBandwidthKiri = parseFloat(avgBandwidthKiri);
          } else if (avgBandwidthKiri.includes("K")) {
            pengali = 1000;
            avgBandwidthKiri = avgBandwidthKiri.replace("K", "");
            avgBandwidthKiri = parseFloat(avgBandwidthKiri);
          } else {
            avgBandwidthKiri = parseFloat(avgBandwidthKiri);
          }
          return { ...data, AverageBandwidth: avgBandwidthKiri * pengali };
        } else {
          avgBandwidthKanan = avgBandwidthKanan.replace("bps", "");
          avgBandwidthKanan = avgBandwidthKanan.replace("(", "");
          avgBandwidthKanan = avgBandwidthKanan.replace(")", "");

          if (avgBandwidthKanan.includes("G")) {
            pengali = 1000000000;
            avgBandwidthKanan = avgBandwidthKanan.replace("G", "");
            avgBandwidthKanan = parseFloat(avgBandwidthKanan);
          } else if (avgBandwidthKanan.includes("M")) {
            pengali = 1000000;
            avgBandwidthKanan = avgBandwidthKanan.replace("M", "");
            avgBandwidthKanan = parseFloat(avgBandwidthKanan);
          } else if (avgBandwidthKanan.includes("K")) {
            pengali = 1000;
            avgBandwidthKanan = avgBandwidthKanan.replace("K", "");
            avgBandwidthKanan = parseFloat(avgBandwidthKanan);
          } else {
            avgBandwidthKanan = parseFloat(avgBandwidthKanan);
          }
          return { ...data, AverageBandwidth: avgBandwidthKanan * pengali };
        }
      }

      function updateTopAttack(topAttack, newAttack) {
        // Ambil currentTime dalam Waktu Indonesia Barat (WIB)
        const currentTimeWIB = new Date(
          new Date().toLocaleString("en-US", { timeZone: "Asia/Jakarta" })
        );
        const currentDay = currentTimeWIB.getDate();
        const currentMonth = currentTimeWIB.getMonth();
        const currentYear = currentTimeWIB.getFullYear();

        // Cek apakah newAttack sudah ada di dalam topAttack berdasarkan id
        const attackExists = topAttack.some(
          (attack) => attack.VictimIp === newAttack.VictimIp
        );

        // Cek apakah StartTime berada pada bulan yang sama dengan currentTime (WIB)
        const startTime = new Date(newAttack.StartTime);
        const isSameMonth =
          startTime.getMonth() === currentMonth &&
          startTime.getFullYear() === currentYear;

        // Jika object tidak ada dalam topAttack
        if (!attackExists) {
          console.log("not exist");

          if (isSameMonth) {
            console.log("same month");
            // Masukkan object ke dalam array pada posisi yang sesuai
            let inserted = false;
            for (let i = 0; i < topAttack.length; i++) {
              if (newAttack.Duration > topAttack[i].Duration) {
                topAttack.splice(i, 0, newAttack);
                inserted = true;
                break;
              }
            }

            // Jika tidak ada object yang lebih besar, push ke akhir array
            if (!inserted) {
              topAttack.push(newAttack);
            }

            // Batasi topAttack menjadi hanya 10 object terbesar
            if (topAttack.length > 10) {
              topAttack.pop();
            }
          }
        } else {
          // jika attack sudah ada di dalam topAttack
          console.log("exist");
          if (!isSameMonth) {
            return topAttack.filter(
              (el) => el["Anomaly Victim IP"] !== newAttack["Anomaly Victim IP"]
            );
          } else {
            topAttack = topAttack.filter((el) => {
              el.VictimIp === el.VictimIp;
            });
            return updateTopAttack(topAttack, newAttack);
          }
        }
        // filter dulu top attack sebelum return
        topAttack = topAttack.filter((item) => {
          const startTime1 = new Date(item.StartTime);
          return (
            startTime1.getMonth() === currentMonth &&
            startTime1.getFullYear() === currentYear
          );
        });
        return topAttack;
      }
      function updateTopOngoingAttack(topAttack, newAttack) {
        // Ambil currentTime dalam Waktu Indonesia Barat (WIB)
        const currentTimeWIB = new Date(
          new Date().toLocaleString("en-US", { timeZone: "Asia/Jakarta" })
        );
        const currentDay = currentTimeWIB.getDate();
        const currentMonth = currentTimeWIB.getMonth();
        const currentYear = currentTimeWIB.getFullYear();

        // Cek apakah newAttack sudah ada di dalam topAttack berdasarkan id
        const attackExists = topAttack.some(
          (attack) => attack.VictimIp === newAttack.VictimIp
        );

        // Jika object tidak ada dalam topAttack
        if (!attackExists) {
          console.log("not exist");
          const startTime = new Date(newAttack.StartTime);

          if (isAttackOnGoing(newAttack)) {
            console.log("onGoing");
            // Masukkan object ke dalam array pada posisi yang sesuai
            let inserted = false;
            for (let i = 0; i < topAttack.length; i++) {
              if (newAttack.Duration > topAttack[i].Duration) {
                topAttack.splice(i, 0, newAttack);
                inserted = true;
                break;
              }
            }

            // Jika tidak ada object yang lebih besar, push ke akhir array
            if (!inserted) {
              topAttack.push(newAttack);
            }

            // Batasi topAttack menjadi hanya 10 object terbesar
            if (topAttack.length > 10) {
              topAttack.pop();
            }
          }
        } else {
          console.log("exist");
          if (!isAttackOnGoing(newAttack)) {
            console.log("not ongoing");
            // sudah tidak on going, sehingga haru sapus dari topOngoingAttack
            return topAttack.filter(
              (el) => el["Anomaly Victim IP"] !== newAttack["Anomaly Victim IP"]
            );
          } else {
            // jika attack sudah ada di dalam topAttack dan masih ongoing
            topAttack = topAttack.filter((el) => {
              el.VictimIp === el.VictimIp;
            });
            return updateTopOngoingAttack(topAttack, newAttack);
          }
        }
        // filter dulu top attack sebelum return
        topAttack = topAttack.filter((item) => {
          const startTime1 = new Date(item.StartTime);
          return item.Status === "Ongoing";
        });
        return topAttack;
      }

      let topAttack = [];
      let topOngoingAttack = [];

      function includeInArray(data, array) {
        const newDestIp = data["Anomaly Host IP"];
        return array.some((item) => item["Anomaly Host IP"] == newDestIp);
      }

      function parseAveragebandwidth(data) {
        const trigeredValue = data["Trigered Value"];
        const unit = data.unit;
      }

      function transformData(data) {
        // ubah Update Time menjadi startTime dan ubah tipedatanya menjadi time
        const StartTime = new Date(data["Creation Time"]);
        // ubah Anomaly Host IP menjadi VictimIp
        const VictimIp = data["Anomaly Host IP"];
        // buat array sourceIp dari SIP1, SIP2, SIP3
        let sourceIp = [];
        if (data.SIP1) {
          sourceIp.push(data.SIP1);
        }
        if (data.SIP2) {
          sourceIp.push(data.SIP2);
        }
        if (data.SIP3) {
          sourceIp.push(data.SIP3);
        }

        // parse Duration
        const currentTimeWIB = new Date(
          new Date().toLocaleString("en-US", { timeZone: "Asia/Jakarta" })
        );
        const Duration = Math.floor((currentTimeWIB - StartTime) / 60000);

        return { StartTime, VictimIp, sourceIp, Duration, ...data };
      }

      // Fungsi untuk memulai listener untuk perubahan data secara real-time
      function listenToDDoSAttacks() {
        ws.onmessage = (event) => {
          const newAttackData = transformData(JSON.parse(event.data));
          // console.log(newAttackData.StartTime);
          // console.log(newAttackData.StartTime.getDate());
          // console.log(newAttackData.StartTime.getMonth());
          // console.log(newAttackData.StartTime.getFullYear());

          if (
            newAttackData.Status === "Ongoing" &&
            !(
              includeInArray(newAttackData, onGoingRedAttack) ||
              includeInArray(newAttackData, onGoingYellowAttack)
            )
          ) {
            // cek apakah red severity atau yellow severity
            if (newAttackData.Severity === "Yellow") {
              onGoingYellowAttack.push(newAttackData);
              renderMarkerByStatus(newAttackData);
              updateOngoingAttackCount(newAttackData);
              updateYellowSeverityOngoingAttackCount(newAttackData);
              topAttack = updateTopAttack(topAttack, newAttackData);
              updateTodoList(topAttack);
              topOngoingAttack = updateTopOngoingAttack(
                topOngoingAttack,
                newAttackData
              );
              updateOnGoingTodoList(topOngoingAttack);
            } else {
              onGoingRedAttack.push(newAttackData);
              renderMarkerByStatus(newAttackData);
              updateOngoingAttackCount(newAttackData);
              updateRedSeverityOngoingAttackCount(newAttackData);
              topAttack = updateTopAttack(topAttack, newAttackData);
              updateTodoList(topAttack);
              topOngoingAttack = updateTopOngoingAttack(
                topOngoingAttack,
                newAttackData
              );
              updateOnGoingTodoList(topOngoingAttack);
            }
          } else if (
            newAttackData.Status === "Recover" &&
            (includeInArray(newAttackData, onGoingRedAttack) ||
              includeInArray(newAttackData, onGoingYellowAttack))
          ) {
            removeAttackById(newAttackData["Anomaly Host IP"]);
            if (newAttackData.Severity === "Yellow") {
              onGoingYellowAttack = onGoingYellowAttack.filter(
                (el) =>
                  el["Anomaly Host IP"] !== newAttackData["Anomaly Host IP"]
              );
              updateOngoingAttackCount(newAttackData);
              updateYellowSeverityOngoingAttackCount(newAttackData);
              removeAttackById(newAttackData["Anomaly Host IP"]);
              topAttack = updateTopAttack(topAttack, newAttackData);
              updateTodoList(topAttack);
              topOngoingAttack = updateTopOngoingAttack(
                topOngoingAttack,
                newAttackData
              );
              updateOnGoingTodoList(topOngoingAttack);
            } else {
              // red severity
              onGoingRedAttack = onGoingRedAttack.filter(
                (el) =>
                  el["Anomaly Host IP"] !== newAttackData["Anomaly Host IP"]
              );
              updateOngoingAttackCount(newAttackData);
              updateRedSeverityOngoingAttackCount(newAttackData);
              removeAttackById(newAttackData["Anomaly Host IP"]);
              topAttack = updateTopAttack(topAttack, newAttackData);
              updateTodoList(topAttack);
              topOngoingAttack = updateTopOngoingAttack(
                topOngoingAttack,
                newAttackData
              );
              updateOnGoingTodoList(topOngoingAttack);
            }
          }
        };

        // const updatedData = docSnapshot.data();
        //     if (updatedData.Status !== "Ongoing") {
        //       // Menghapus elemen terkait dengan ID khusus
        //       g.selectAll(
        //         `.marker-${attackId}, .pulse-${attackId}, .line-${attackId}`
        //       ).remove();
        //       marker = null;
        //       startPulseAnimation = false;
        //     }

        // const ddosAttackCollection = collection(db, "DDoSAttack");
        // // Memulai listener untuk memantau perubahan
        // onSnapshot(ddosAttackCollection, (snapshot) => {
        //   snapshot.docChanges().forEach((change) => {
        //     if (change.type === "added") {
        //       const newAttackData = { id: change.doc.id, ...change.doc.data() };
        //       const formatedData = formatData(newAttackData);
        //       topAttack = updateTopAttack(topAttack, formatedData);
        //       console.log(topAttack);
        //       updateTodoList(topAttack);
        //       if (
        //         newAttackData.Status === "Ongoing" &&
        //         !(
        //           onGoingRedAttack.includes(newAttackData.id) ||
        //           onGoingYellowAttack.includes(newAttackData.id)
        //         )
        //       ) {
        //         renderMarkerByStatus(newAttackData);
        //       } else {
        //         if (
        //           !(
        //             onGoingRedAttack.includes(newAttackData.id) ||
        //             onGoingYellowAttack.includes(newAttackData.id)
        //           )
        //         ) {
        //           renderMarkerByEndTime(newAttackData);
        //         }
        //       }
        //       addOnGoingAttack(newAttackData);
        //     }
        //     if (change.type === "modified") {
        //       const newAttackData = { id: change.doc.id, ...change.doc.data() };
        //       const formatedData = formatData(newAttackData);
        //       topAttack = updateTopAttack(topAttack, formatedData);
        //       console.log({ onGoingRedAttack, onGoingYellowAttack });
        //       updateTodoList(topAttack);
        //       if (
        //         newAttackData.Status === "Ongoing" &&
        //         !(
        //           onGoingRedAttack.includes(newAttackData.id) ||
        //           onGoingYellowAttack.includes(newAttackData.id)
        //         )
        //       ) {
        //         renderMarkerByStatus(newAttackData);
        //       } else {
        //         if (
        //           !(
        //             onGoingRedAttack.includes(newAttackData.id) ||
        //             onGoingYellowAttack.includes(newAttackData.id)
        //           )
        //         ) {
        //           renderMarkerByEndTime(newAttackData);
        //         }
        //       }
        //       addOnGoingAttack(newAttackData);
        //       removeOnGoingAttack(newAttackData);
        //       console.log({ onGoingRedAttack, onGoingYellowAttack });
        //       console.log("Modified data: ", change.doc.data());
        //     }
        //     if (change.type === "removed") {
        //       const removedAttackdata = {
        //         id: change.doc.id,
        //         ...change.doc.data(),
        //       };
        //       const formatedData = formatData(removedAttackdata);
        //       topAttack = updateTopAttack(topAttack, formatedData);
        //       updateTodoList(topAttack);
        //       console.log("Removed data: ", change.doc.data());
        //       const removedItem = itemMap.get(change.doc.id);
        //       if (removedItem) {
        //         todoList.removeChild(removedItem);
        //         itemMap.delete(change.doc.id);
        //       }
        //       removeOnGoingAttack(removedAttackdata);
        //     }
        //   });
        // });
      }

      function setNewDuration(data) {
        let returnVal = data;
        const currentTimeWIB = new Date(
          new Date().toLocaleString("en-US", { timeZone: "Asia/Jakarta" })
        );
        const Duration = Math.floor((currentTimeWIB - data.StartTime) / 60000);
        returnVal.Duration = Duration;
        return returnVal;
      }

      // Panggil fungsi untuk memulai listener
      listenToDDoSAttacks();

      // set interval 1 menit untuk memperbarui duration yang ada di current attack
      setInterval(() => {
        // lakukan for loop untuk setiap ongoing attack (red dan yellow)
        for (let i = 0; i < onGoingRedAttack.length; i++) {
          // untuk setiap itemnya, update duration, perbarui topAttack, dan perbarui todo list
          onGoingRedAttack[i] = setNewDuration(onGoingRedAttack[i]);
          topAttack = updateTopAttack(topAttack, onGoingRedAttack[i]);
          updateTodoList(topAttack);
          topOngoingAttack = updateTopOngoingAttack(
            topOngoingAttack,
            onGoingRedAttack[i]
          );
          updateOnGoingTodoList(topOngoingAttack);
        }
        for (let j = 0; j < onGoingYellowAttack.length; j++) {
          // untuk setiap itemnya, update duration, perbarui topAttack, dan perbarui todo list
          onGoingYellowAttack[j] = setNewDuration(onGoingYellowAttack[j]);
          topAttack = updateTopAttack(topAttack, onGoingYellowAttack[j]);
          updateTodoList(topAttack);
          topOngoingAttack = updateTopOngoingAttack(
            topOngoingAttack,
            onGoingYellowAttack[j]
          );
          updateOnGoingTodoList(topOngoingAttack);
        }
        console.log({
          topAttack,
          topOngoingAttack,
          onGoingYellowAttack,
          onGoingRedAttack,
        });
      }, 5000);

      // updateOngoingAttackCount();
      // updateRedSeverityOngoingAttackCount();
      // updateYellowSeverityOngoingAttackCount();

      // TOOLTIP
      // Dapatkan referensi ke tooltip
      const tooltip = select("#tooltip");

      // Fungsi untuk menampilkan tooltip
      function showTooltip(event, data) {
        tooltip
          .style("left", `${event.pageX + 10}px`) // Posisi tooltip sedikit offset dari kursor
          .style("top", `${event.pageY + 10}px`)
          .style("display", "block")
          .style("background-color", "#060714") // Background berwarna #060714
          .style("color", "white") // Teks berwarna putih
          .html(`
        <strong>Resource:</strong> ${data.Resource}<br>
        <strong>Sub-type:</strong> ${data["Sub-type"]}<br>
        <strong>Anomaly Host IP:</strong> ${data["Anomaly Host IP"]}<br>
        <strong>Start Time:</strong> ${data.StartTime.toLocaleString()}
      `);
      }

      // Fungsi untuk menyembunyikan tooltip
      function hideTooltip() {
        tooltip.style("display", "none");
      }

      // Kode untuk memuat peta dan melakukan setup D3.js
      const svg = select("svg");

      const width = parseFloat(svg.style("width"));
      const height = parseFloat(svg.style("height"));

      const projection = geoNaturalEarth1()
        .scale(250)
        .translate([width / 2, height / 2]);

      const pathGenerator = geoPath().projection(projection);

      const g = svg.append("g"); // Grup yang akan digunakan untuk zoom dan panning

      // Tambahkan sphere ke dalam grup `g`
      g.append("path")
        .attr("d", pathGenerator({ type: "Sphere" }))
        .attr("fill", "black");

      svg.call(
        zoom()
          .scaleExtent([1, 8])
          .on("zoom", (event) => {
            g.attr("transform", event.transform);
          })
      );

      json("https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json")
        .then((data) => {
          const countries = topojson.feature(data, data.objects.countries);

          g.selectAll("path")
            .data(countries.features)
            .enter()
            .append("path")
            .attr("class", "land")
            .attr("d", pathGenerator)
            .append("title")
            .text((d) => d.properties.name || "Unknown");
        })
        .catch((error) => console.error("Error fetching map data:", error));

      // Kode untuk menu dan resize event
      const allSideMenu = document.querySelectorAll(
        "#sidebar .side-menu.top li a"
      );

      allSideMenu.forEach((item) => {
        const li = item.parentElement;

        item.addEventListener("click", function () {
          allSideMenu.forEach((i) => {
            i.parentElement.classList.remove("active");
          });
          li.classList.add("active");
        });
      });

      window.addEventListener("resize", function () {
        if (this.innerWidth > 576) {
          searchButtonIcon.classList.replace("bx-x", "bx-search");
          searchForm.classList.remove("show");
        }
      });
    </script>
  </body>
</html>
